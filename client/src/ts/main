// import type { Circuit } from './scene/objects/circuit.js';
// import { Wire } from './scene/objects/wire.js';
// import { SimEngine } from './engine.js';

// import { SceneManager, Scene } from './scene/scene-manager.js';
// import { ViewManager } from './view-manager.js';
// import { MouseStateMachine } from '@ts/interactivity/mouse/state-machine';
// import { TouchScreenStateMachine } from './interactivity/touchscreen/state-machine.js';
// import { creators, customCircuitCreator } from './circuit-creators.js';
// import { CreatingCircuit as CreatingCircuitMouse } from './interactivity/mouse/states/creating-circuit.js';
// import { CreatingCircuit as CreatingCircuitTouchScreen } from './interactivity/touchscreen/states/creating-circuit.js';

// export let simEngine = new SimEngine();
// export let viewManager = new ViewManager();
// export let mouseStateMachine = new MouseStateMachine();
// export let touchScreenStateMachine = new TouchScreenStateMachine();

// export let customCircuitScenes = new Map<string, number>([['Main', SceneManager.HOME_SCENE_ID]]);
// export let sceneManager = new SceneManager();

// export let clipboard = {
// 	circuits: new Array<Circuit>(),
// 	wires: new Array<Wire>()
// };

// export function circuitCreators(currentScene: Scene | undefined = undefined) {
// 	let circuitButtons = document.getElementById('circuit-buttons');
// 	if (circuitButtons == null) {
// 		domLog('[Error] No container for circuit buttons');
// 		throw Error();
// 	}
// 	circuitButtons.replaceChildren();

// 	for (let [name, creator] of creators.entries()) {
// 		if (currentScene && name === currentScene.name) {
// 			continue;
// 		}
// 		let button = document.createElement('button');
// 		button.innerHTML = name;
// 		button.onclick = (ev) => {
// 			console.log(`${name} clicked`);
// 			mouseStateMachine.state = new CreatingCircuitMouse(name, creator);
// 			touchScreenStateMachine.state = new CreatingCircuitTouchScreen(name, creator);
// 		};
// 		circuitButtons.appendChild(button);
// 	}
// }

// function customCircuits() {
// 	let customCircuitDom = document.getElementById('custom-circuits');
// 	if (customCircuitDom == null) {
// 		throw Error();
// 	}
// 	customCircuitDom.replaceChildren();

// 	for (let [name, sceneId] of customCircuitScenes.entries()) {
// 		// if (name === currentScene.name) {
// 		//   continue;
// 		// }

// 		let button = document.createElement('button');
// 		button.innerHTML = name;
// 		button.onclick = (ev) => {
// 			console.log(`Switching to ${name} scene`);
// 			sceneManager.setCurrentScene(sceneId);
// 		};
// 		customCircuitDom.appendChild(button);
// 	}
// }

// function populateUI() {
// 	circuitCreators();
// 	customCircuits();

// 	{
// 		let newCustomCircuit = document.getElementById('new-custom-circuit');
// 		if (newCustomCircuit == null) {
// 			console.log('newCircuitCreator == null');
// 			return;
// 		}
// 		let newCustomCircuitButton = document.createElement('button');

// 		newCustomCircuitButton.innerHTML = 'New Custom Circuit';
// 		newCustomCircuitButton.onclick = (ev) => {
// 			let tmp = prompt('Enter name for custom circuit');
// 			while (true) {
// 				if (tmp == null) {
// 					return;
// 				}
// 				if (tmp.trim() === '') {
// 					tmp = prompt('The name for the custom circuit cannot be empty');
// 					continue;
// 				}
// 				if (creators.get(tmp) != null) {
// 					tmp = prompt('The provided name has already been used for another circuit');
// 					continue;
// 				}
// 				break;
// 			}
// 			const circuitName = tmp;
// 			const sceneId = sceneManager.newCustomScene();

// 			let scene = sceneManager.scenes.get(sceneId);
// 			if (scene == null) {
// 				throw Error();
// 			}
// 			scene.name = circuitName;

// 			creators.set(circuitName, customCircuitCreator(circuitName));
// 			circuitCreators();

// 			customCircuitScenes.set(circuitName, sceneId);
// 			customCircuits();

// 			sceneManager.setCurrentScene(sceneId);
// 		};

// 		newCustomCircuit.appendChild(newCustomCircuitButton);
// 	}
// }
// populateUI();

// let tickButton = document.getElementById('tick');
// if (tickButton !== null) {
// 	tickButton.onclick = (ev) => {
// 		simEngine.tick();
// 	};
// }

// let pauseButton = document.getElementById('pause');
// if (pauseButton !== null) {
// 	pauseButton.onclick = (ev) => {
// 		simEngine.paused = true;
// 	};
// }

// let runButton = document.getElementById('run');
// if (runButton !== null) {
// 	runButton.onclick = (ev) => {
// 		simEngine.runSim();
// 	};
// }

// setInterval(function () {
// 	sceneManager.draw(ctx);
// 	console.log('draw');
// }, 1000 / 60);
// // scheduler.runSim(ctx);
